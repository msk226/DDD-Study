# DDD를 적용하며 겪은 고민들
처음 DDD를 적용해보자고 마음먹었을 때, 사실 어디서부터 시작해야 할지 감이 잘 안 잡혔다. 

엔티티와 VO를 분류하고, 바운디드 컨텍스트를 정하고, 계층을 나누고... 해야 할 게 많다는 건 알겠는데, 어떤 순서로 어떤 태스크부터 진행해야 할지 정리가 잘 안됐다. 그래서 처음으로 돌아가서 ‘내가 이걸 그린필드에서 새로 만든다고 생각해보자. 뭐 부터 하면 좋을까?’ 부터 고민해보기로 했다. 그리고 이 고민을 정리하는 방법으로 **유즈케이스 작성**을 선택했다. 

유즈케이스를 작성하면서 도메인을 더 깊이 이해할 수 있었고, 기획자나 다른 협업자와 논의할 수 있는 좋은 소통 도구가 될 수도 있다고 느꼈다. 또한, DTO나 API 설계에도 자연스럽게 도움을 줄 수 있는 포맷이라고 생각했다.
예전엔 ‘요즘도 저런 거 일일이 쓰는 사람이 있나?’ 싶었지만, 막상 써보니 작성하는 데 드는 시간 이상의 가치를 줬다. **오히려 유즈케이스를 잘 정리해둘수록 실제 코드의 완성도가 훨씬 높아졌다.**

 이번에는 유효성 조건, 성공/실패 조건, 예외 흐름 정도만 간략하게 작성했는데도 큰 도움이 됐다.

# 계층 간 책임 분리에 대한 새로운 시선
DDD를 적용하면서 가장 크게 느꼈던 변화 중 하나는 **각 계층의 책임을 명확히 분리하는 것**이었다.

 예전에는 이런 식의 구조를 고민해본 적이 거의 없었다. 예를 들어 QuestionRepository를 도메인 계층에 인터페이스로 두고, 그 구현체를 infrastructure 계층에 두는 방식은 진짜 보고 나서 감탄이 나올 정도였다. 이게 바로 **결합도를 낮추는 방식**이고, 이런 구조가 되니까 테스트 작성도 훨씬 쉬워졌다.

과거에 진행했던 SPOT 프로젝트에서도 테스트 코드 작성이 어렵다는 느낌이 있었는데, 지금 생각해보면 그건 결국 구조의 결합도가 너무 높았기 때문이었다. 그때 이런 구조를 알았더라면, 테스트뿐만 아니라 확장도 훨씬 쉬웠을 거다.

그리고 예전에는 깊이 고민하지 않았던 것도, 이번엔 진지하게 고민하게 됐다. 대표적인 게 **JWT 관련 코드는 어느 계층에 둬야 할까?** 하는 거였다. 처음엔 회원 정보를 사용하는 거니까 application 계층에 둬야 하나 고민했지만, 결국 인증/보안은 도메인 로직이 아니라 시스템 인프라에 가깝다고 판단해서 infrastructure 계층에 두기로 했다. 그리고 인증/인가 처리는 Spring Security의 필터 계층에서 담당하도록 구성했다. 그렇게 구조를 잡으니까 코드도 훨씬 깔끔하고 명확해졌다.

# Command 객체를 왜 써야 할까?
처음엔 요청 DTO를 그냥 유즈케이스에서 바로 써도 될 것 같다고 생각했다. 하지만 구조가 조금만 복잡해지거나, 요청 값이 여러 계층을 지나면서 가공돼야 할 때 **Command 객체**가 그 사이의 매개 역할을 해주는 게 훨씬 깔끔했다.

Command는 단순히 값을 옮기는 객체가 아니라, “이 유즈케이스는 어떤 의도를 갖고 동작한다”는 **계약의 역할**을 해준다. 그리고 그 Command 객체는 유즈케이스 단위로 설계되기 때문에, SRP 원칙에도 딱 맞는다.

# 조회 쿼리 분리, CQRS 적용
이번 구조에서 가장 많은 영향을 준 개념 중 하나는 **CQRS (Command Query Responsibility Segregation)** 패턴이었다.

 간단히 말해서, **명령(Insert/Update/Delete)과 조회(Select)를 아예 다른 책임과 모델로 분리한 설계**다.
처음에는 단순히 기능 나누기 정도로 생각했는데, 설계를 하면서 점점 **이 둘은 결이 완전히 다르다**는 걸 체감하게 됐다.
* Command 쪽은 대부분 단순한 식별자 기반의 조회 + 상태 변경
* Query 쪽은 복잡한 조건 조합, 통계, 조인 등 다양한 쿼리가 필요

이 둘을 한 Repository에서 관리하면 억지로 하나에 기능을 우겨넣게 되고, 나중엔 확장성이나 유지보수 측면에서도 한계가 온다. 그래서 Command용 Repository는 JPA 기반으로 도메인 중심으로 유지하고, Query용 Repository는 QueryDSL 기반으로 DTO를 바로 반환하도록 구성했다. 덕분에 각 목적에 맞는 기술을 유연하게 사용할 수 있었다.

나중에는 **조회 DB와 쓰기 DB를 아예 분리하는 구조까지 확장할 수 있는 기반**이 되기도 하고, 비즈니스 규칙을 지켜야 하는 쪽은 도메인 로직이, 그 외 보여주기 위한 조회는 DTO로 유연하게 처리할 수 있게 됐다.

물론, 이런 구조는 작성해야 할 코드가 많아지는 단점도 있었다. 하지만 명확한 책임 분리 덕분에 **코드가 길어져도 읽기 쉽고 명확해졌다는 점이 더 큰 이점**이었다.


